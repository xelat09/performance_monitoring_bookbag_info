:guid: %guid%
:user: %user%
:sectlinks:
:sectanchors:
:markup-in-source: verbatim,attributes,quotes
:source-highlighter: highlight.js
[[micronaut]]
= Developing the Micronaut Application

[IMPORTANT]
====
Due to our Lab session time constraint, we already provided the code for the app, so you have time to experience other exiting capabilities available in the Platform.

This version of the app implements the same logic, exposing the exact same http resources, but now using *Micronaut* as its underline Runtime.

Feel free to go through the source code. But #*you don't need to code any Java Class in this section*#. 

*You can jump right to the* link:#Running-the-Micronaut-Application-Locally[*Running the Micronaut Application Locally*] section and just run the Maven commands (or run the Tasks using the IDE Task Manager) to run and test the app inside your DevWorkspace.
====

In this section you will:

* Develop a REST API with Micronaut that consumes memory and CPU (the exact same algorithm than before)
* Add a Statistics persistent entity to store metrics in a PostgreSQL database
* Configure the application
* Develop some tests to validate the behavior of the application
* Test and run the application locally
* Check a few metrics locally

You should have a directory called `micronaut-app` inside your project repo (`$PROJECT_SOURCE/`). This is the root of the Micronaut microservice source code that we will be working on during this this section.

== The Micronaut REST Resource

The Micronaut application is also made of a simple REST resource that exposes the endpoints that consume memory and CPU.
Before creating the REST resource, let's check the existing main Micronaut class that will bootstrap the application.
Open the `MicronautApplication` class under the `io/containerapps/javaruntime/workshop/micronaut` package.

[[micronaut-listing-rest-resource]]
.Bootstrapping Micronaut Class
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.micronaut;

import io.micronaut.runtime.Micronaut;

public class MicronautApplication {

    public static void main(String[] args) {
        Micronaut.run(MicronautApplication.class, args);
    }
}
----

The REST resource is defined in the `MicronautResource` class.
Create a new file called `MicronautResource.java` under the `src/main/java/io/containerapps/javaruntime/workshop/micronaut` directory. Then add the following to the header of this class file (replacing any existing content generated by the IDE).

As you can see in the header of the class, the resource is exposed on the `/micronaut` path.

[[micronaut-listing-rest-resource-1]]
.Header of the Micronaut REST Resource
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.micronaut;

import io.micronaut.http.MediaType;
import io.micronaut.http.annotation.Controller;
import io.micronaut.http.annotation.Get;
import io.micronaut.http.annotation.QueryValue;

import java.lang.System.Logger;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import static java.lang.System.Logger.Level.INFO;
import static java.lang.invoke.MethodHandles.lookup;

@Controller("/micronaut")
public class MicronautResource {

    private static final Logger LOGGER = System.getLogger(lookup().lookupClass().getName());

    private final StatisticsRepository repository;

    public MicronautResource(StatisticsRepository statisticsRepository) {
        this.repository = statisticsRepository;
    }


}
----

Let's add a `hello` method returning _Hello World_ so we can quickly check if our endpoint responds or not.

[[micronaut-listing-rest-resource-2]]
.Hello Method
[source,java,indent=0,role=copy]
----
    @Get(produces = MediaType.TEXT_PLAIN)
    public String hello() {
        LOGGER.log(INFO, "Micronaut: hello");
        return "Micronaut: hello";
    }
----

Let's now add a `cpu` method that consumes CPU depending on a few optional parameters.

* `iterations`: the more iterations you have, the more CPU it consumes.
* `db`: if this parameter is set to true, the statistics are stored in the database.
That allows us to check the impact of the database on the CPU consumption.
* `desc`: any optional description you want to persist in the database

[[micronaut-listing-rest-resource-3]]
.CPU Method
[source,java,indent=0,role=copy]
----
    @Get(uri = "/cpu", produces = MediaType.TEXT_PLAIN)
    public String cpu(@QueryValue(value = "iterations", defaultValue = "10") Long iterations,
                      @QueryValue(value = "db", defaultValue = "false") Boolean db,
                      @QueryValue(value = "desc", defaultValue = "") String desc) {
        LOGGER.log(INFO, "Micronaut: cpu: {0} {1} with desc {2}", iterations, db, desc);
        Long iterationsDone = iterations;
    
        Instant start = Instant.now();
        if (iterations == null) {
            iterations = 20000L;
        } else {
            iterations *= 20000;
        }
        while (iterations > 0) {
            if (iterations % 20000 == 0) {
                try {
                    Thread.sleep(20);
                } catch (InterruptedException ie) {
                }
            }
            iterations--;
        }
    
        if (db) {
            Statistics statistics = new Statistics();
            statistics.type = Type.CPU;
            statistics.parameter = iterations.toString();
            statistics.duration = Duration.between(start, Instant.now());
            statistics.description = desc;
            repository.save(statistics);
        }
    
        String msg = "Micronaut: CPU consumption is done with " + iterationsDone + " iterations in " + Duration.between(start, Instant.now()).getNano() + " nano-seconds.";
        if (db) {
            msg += " The result is persisted in the database.";
        }
        return msg;
    }
----

Now, add a `memory` method that consumes memory depending on a few optional parameters.

* `bites`: the more bits you have, the more memory it consumes.
* `db`: if this parameter is set to true, the statistics are stored in the database.
* `desc`: any optional description you want to persist in the database

[[micronaut-listing-rest-resource-4]]
.Memory Method
[source,java,indent=0,role=copy]
----
    @Get(uri = "/memory", produces = MediaType.TEXT_PLAIN)
    public String memory(@QueryValue(value = "bites", defaultValue = "10") Integer bites,
                         @QueryValue(value = "db", defaultValue = "false") Boolean db,
                         @QueryValue(value = "desc", defaultValue = "") String desc) {
        LOGGER.log(INFO, "Micronaut: memory: {0} {1} with desc {2}", bites, db, desc);
    
        Instant start = Instant.now();
        if (bites == null) {
            bites = 1;
        }
        HashMap hunger = new HashMap<>();
        for (int i = 0; i < bites * 1024 * 1024; i += 8192) {
            byte[] bytes = new byte[8192];
            hunger.put(i, bytes);
            for (int j = 0; j < 8192; j++) {
                bytes[j] = '0';
            }
        }
    
        if (db) {
            Statistics statistics = new Statistics();
            statistics.type = Type.MEMORY;
            statistics.parameter = bites.toString();
            statistics.duration = Duration.between(start, Instant.now());
            statistics.description = desc;
            repository.save(statistics);
        }
    
        String msg = "Micronaut: Memory consumption is done with " + bites + " bites in " + Duration.between(start, Instant.now()).getNano() + " nano-seconds.";
        if (db) {
            msg += " The result is persisted in the database.";
        }
        return msg;
    }
----

Let's also create a method to retrieve the statistics from the database.

[[micronaut-listing-rest-resource-5]]
.Method Returning all the Statistics
[source,java,indent=0,role=copy]
----
    @Get(uri = "/stats", produces = MediaType.APPLICATION_JSON)
    public List<Statistics> stats() {
        LOGGER.log(INFO, "Micronaut: retrieving statistics");
        List<Statistics> result = new ArrayList<Statistics>();
        for (Statistics stats : repository.findAll()) {
            result.add(stats);
        }
        return result;
    }
----

At this stage the code does not compile yet, because there are a few missing classes.
Let's create them now.

== Transactions and ORM

When the database is enabled, the statistics are stored in the database.
For that we need a `Statistics` entity with a few enumerations that will be mapped to the PostgreSQL database.
Create the `Statistics.java` entity in the `src/main/java/io/containerapps/javaruntime/workshop/micronaut` directory.

[[micronaut-listing-entity]]
.Statistics Entity
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.micronaut;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;
import java.time.Duration;
import java.time.Instant;

@Entity
@Table(name = "Statistics_Micronaut")
public class Statistics {

    @GeneratedValue
    @Id
    private Long id;
    @Column(name = "done_at")
    public Instant doneAt = Instant.now();
    public Framework framework = Framework.MICRONAUT;
    public Type type;
    public String parameter;
    public Duration duration;
    public String description;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }
}

enum Type {
    CPU, MEMORY
}

enum Framework {
    QUARKUS, MICRONAUT, SPRINGBOOT
}
----

For manipulating the entity, we need a repository.
Create the `StatisticsRepository.java` class under the same package.

[[micronaut-listing-repository]]
.Statistics Repository
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.micronaut;

import io.micronaut.data.annotation.Repository;
import io.micronaut.data.repository.CrudRepository;

@Repository
interface StatisticsRepository extends CrudRepository<Statistics, Long> {
  
}
----

[#Compiling-the-Micronaut-Application]
== Compiling the Micronaut Application

You should have all the code to compile the application.
To make sure you have all the code and dependencies, run the following command in the `micronaut-app` folder:

[source,shell,role=copy]
----
cd $PROJECT_SOURCE/micronaut-app
mvn compile
----

[TIP]
====
Besides using Maven commands directly in the IDE Terminal you can use the pre-defined commands available as Tasks in your Workspace.
To access these commands just open the Task Manager view at left menu of your IDE (see screenshot below) and choose the task named `04: Micronaut - JVM Package` which triggers a `mvn package -DskipTests` in a separate Terminal.

.*Click to see how use the Task Manager inside your DevWorkspace*
[%collapsible]
=====
image::../imgs/module-3/VSCode_task_manager_mvn_package.gif[Task Manager - JVM Package]
=====

All these Tasks are defined as `commands` in the project's *Devfile* (`$PROJECT_SOURCE/devfile.yaml`) following the link:https://devfile.io[Devfile.io] standard.
====

[NOTE]
====
At this point, you may be asking yourself about the Maven dependencies since we haven't touched the project's `pom.xml`. That's true. To make things a bit easier during the Lab, we have already set all the project dependencies for you.
You can check the `micronaut-app/pom.xml` file by opening it in the editor if you want to.
====

== Configuring the Micronaut Application

During our development and testing phase we will be using an InMemory Database (link:https://www.h2database.com/[H2] in our case). Later when we will be deploying our app to our Openshift Cluster we will switch to a Postgres SQL Database instance.

In Dev we also need this service to be exposed on the port 8702 (different port from the Quarkus application).
Notice that we use non-blocking threads (`thread-selection: IO`).

To accommodate all these specific environment configurations we need to leverage what Micronaut calls link:https://docs.micronaut.io/latest/guide/#environments[Application Environment]. With that we can have specific config files per environment and at runtime we can activate them by using the System Property `-Dmicronaut.environments`.

Add the following to the `src/main/resources/application-dev.yml` file.

[[micronaut-listing-config]]
.Configuration Properties
[source,yaml,indent=0]
----
micronaut:
  application:
    name: MicronautApp
  server:
    port: 8702
    thread-selection: IO
  metrics:
    enabled: true

netty:
  default:
    allocator:
      max-order: 3

datasources:
  default:
    dialect: H2
    url: ${JDBC_URL:`jdbc:h2:mem:default;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE`}
    username: ${JDBC_USER:sa}
    password: ${JDBC_PASSWORD:""}
    driverClassName: ${JDBC_DRIVER:org.h2.Driver}

jpa:
  default:
    entity-scan:
      packages: 'io.containerapps.javaruntime.workshop.micronaut'
    properties:
      hibernate:
        bytecode:
          provider: none
        hbm2ddl:
          auto: update
        show_sql: true
----

== Testing the Micronaut Application Locally

Now, to make sure that the application works as expected, we need to write some tests.
For our Unit Tests we will also use H2 DB. A configuration file for testing is already provided (see `src/test/resources/application.yml`) configuring a Datasource for H2DB.

Open the `MicronautAppTest` class under the `src/test/java/io/containerapps/javaruntime/workshop/micronaut` folder and add the following code.

[[micronaut-listing-test]]
.Test Class Configuring Testcontainers
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.micronaut;

import io.micronaut.runtime.EmbeddedApplication;
import io.micronaut.test.extensions.junit5.annotation.MicronautTest;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;
import jakarta.inject.Inject;

@MicronautTest
class MicronautAppTest {

    @Inject
    EmbeddedApplication<?> application;

    @Test
    void testItWorks() {
        Assertions.assertTrue(application.isRunning());
    }

}
----

Then, all our tests go into the `MicronautResourceTest` class.
Create the `MicronautResourceTest.java` class under the same package that `MicronautAppTest`.

[[micronaut-listing-test-1]]
.Header of the Test Class
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.micronaut;

import io.micronaut.test.extensions.junit5.annotation.MicronautTest;
import io.restassured.specification.RequestSpecification;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.*;

@MicronautTest
class MicronautResourceTest {

    private static String basePath = "http://localhost:8802/micronaut";
}
----

First, let's write a test to check that the `hello` method returns the right _Hello World_ string.

[[micronaut-listing-test-2]]
.Testing the Hello Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testHelloEndpoint(RequestSpecification spec) {
        spec
          .when().get(basePath)
          .then()
            .statusCode(200)
            .body(is("Micronaut: hello"));
    }
----

Then, we write another test to check that the `cpu` method consumes CPU and takes the right parameters.

[[micronaut-listing-test-3]]
.Testing the CPU Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testCpuWithDBAndDescEndpoint() {
        given().param("iterations", 1).param("db", true).param("desc", "Java17")
          .when().get(basePath + "/cpu")
          .then()
            .statusCode(200)
            .body(startsWith("Micronaut: CPU consumption is done with"))
            .body(not(containsString("Java17")))
            .body(endsWith("The result is persisted in the database."));
    }
----

And we do the same for the `memory` method.

[[micronaut-listing-test-4]]
.Testing the Memory Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testMemoryWithDBAndDescEndpoint() {
        given().param("bites", 1).param("db", true).param("desc", "Java17")
          .when().get(basePath + "/memory")
          .then()
            .statusCode(200)
            .body(startsWith("Micronaut: Memory consumption is done with"))
            .body(not(containsString("Java17")))
            .body(endsWith("The result is persisted in the database."));
    }
----

Let's also create a simple test to make sure the statistics are stored in the database.

[[micronaut-listing-test-5]]
.Testing Retrieving the Statistics from the Database
[source,java,indent=0,role=copy]
----
    @Test
    public void testStats() {
        given()
            .when().get(basePath + "/stats")
            .then()
            .statusCode(200);
    }
----

Now that you have your tests methods, run them with the following command:

[source,shell,role=copy]
----
cd $PROJECT_SOURCE/micronaut-app
mvn test
----

[NOTE]
====
A pop-up saying "*A new process is now listening on port 8882...*" may appear at the bottom left during the test run. Just click `No` or close it! 
====

All the tests should pass and you should see the following output:

[source,shell]
----
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

[TIP]
====
You can also use the Task Manager to trigger Maven Test by executing the task `06: Micronaut - Test` which triggers a `mvn test` in a separate Terminal.
====

[#Running-the-Micronaut-Application-Locally]
== Running the Micronaut Application Locally

Now that the tests are all green, let's execute the application locally and execute a few `curl` commands to  to test the exposed endpoints.

Execute the following command inside the `micronaut-app` directory:

[source,shell,role=copy]
----
cd $PROJECT_SOURCE/micronaut-app
mvn -Dmicronaut.environments=dev mn:run
----

[NOTE]
====
notice the `-Dmicronaut.environments=dev` system property instructing the runtime to use `application-dev.yml` config file.
====

[TIP]
====
You can also use the Task Manager to start Micronaut in Dev Mode by executing the task `05: Micronaut - Start in dev mode` which triggers a `mvn mn:run` in a separate Terminal.
====

[NOTE]
====
When you start the Micronaut app in dev mode inside your Workspace watch out for a pop-up that appear at the bottom left of your IDE.

 * the pop-up one says "Process micronaut-app is now listening on port 8702" which is the http port we configured our app to listen to. *click Open in a new tab button* and then *click Open* in the next pop-up (VSCode needs your consent every time you attempt to open an external URL).

This pop-up will appear every time you start a process which listens to a TCP/HTTP port. This is how *DevSpaces* exposes your app for external access during development phase.
====

In another terminal you can execute the following `curl` commands to invoke the endpoint:

[source,shell,role=copy]
----
curl -w '\n' 'localhost:8702/micronaut'
curl -w '\n' 'localhost:8702/micronaut/cpu?iterations=10&db=true&desc=java17'
curl -w '\n' 'localhost:8702/micronaut/memory?bites=10&db=true&desc=java17'
----

You can change the parameters to see how the application behaves.
Change the number of iterations and the number of bites to see how the performance is impacted (with and without database).

[source,shell,role=copy]
----
curl -w '\n' 'localhost:8702/micronaut/cpu?iterations=50'
curl -w '\n' 'localhost:8702/micronaut/cpu?iterations=100'
curl -w '\n' 'localhost:8702/micronaut/cpu?iterations=100&db=true&desc=smoke%20test'

curl -w '\n' 'localhost:8702/micronaut/memory?bites=50'
curl -w '\n' 'localhost:8702/micronaut/memory?bites=100'
curl -w '\n' 'localhost:8702/micronaut/memory?bites=100&db=true&desc=smoke%20test'
----

You can check the content of the database with:

[source,shell,role=copy]
----
curl -s 'localhost:8702/micronaut/stats' | jq
----

You should see an output like the following.

[source, json]
----
[
  {
    "id": 1,
    "doneAt": "2023-05-16T14:16:37.744772Z",
    "framework": "MICRONAUT",
    "type": "CPU",
    "parameter": "0",
    "duration": 0.211009419,
    "description": "java17"
  },
  {
    "id": 2,
    "doneAt": "2023-05-16T14:16:49.520952Z",
    "framework": "MICRONAUT",
    "type": "MEMORY",
    "parameter": "10",
    "duration": 0.023290367,
    "description": "java17"
  },
  {
    "id": 3,
    "doneAt": "2023-05-16T14:18:11.559207Z",
    "framework": "MICRONAUT",
    "type": "CPU",
    "parameter": "0",
    "duration": 2.039769092,
    "description": "smoke test"
  },
  {
    "id": 4,
    "doneAt": "2023-05-16T14:18:28.166053Z",
    "framework": "MICRONAUT",
    "type": "MEMORY",
    "parameter": "100",
    "duration": 0.188299506,
    "description": "smoke test"
  }
]
----

That's it for the Micronaut application.
We now have the Quarkus and Micronaut application fully tested, up and running, time to write the Spring Boot application.
