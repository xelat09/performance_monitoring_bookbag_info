:guid: %guid%
:user: %user%
:sectlinks:
:sectanchors:
:markup-in-source: verbatim,attributes,quotes
:source-highlighter: highlight.js
[[quarkus]]
= Developing the Quarkus Application

In this section you will:

* Develop a REST API with Quarkus that consumes memory and CPU
* Add a Statistics persistent entity to store metrics in a PostgreSQL database
* Configure the application
* Develop some tests to validate the behavior of the application
* Test and run the application locally
* Check a few metrics locally

You should have a directory called `quarkus-app` inside your project repo (`$PROJECT_SOURCE/`). This is the root of the Quarkus microservice source code that we will be working on during this this section.

== The Quarkus REST Resource

The Quarkus application is made of a simple REST resource that consumes memory and CPU. The resource is defined in the `QuarkusResource` class.

*Create a new file* called `QuarkusResource.java`, under the `src/main/java/io/containerapps/javaruntime/workshop/quarkus` directory. 

[IMPORTANT]
====
Maven based projects follows a link:https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html[standard directory layout].

Application classes containing domain and logic *must* reside under the `src/main/java/` directory.

[source, subs=+quotes]
-----
.
├── pom.xml
├── src
│   ├── #main#
│   │   ├── java
│   │   │   └── ... 
-----
====

Then add the following to the header of this class file (replacing any existing content auto-generated by the IDE when you first created this class file).

As you can see, it's a JAX-RS resource that exposes the `/quarkus` path.

[[quarkus-listing-rest-resource-1]]
.Header of the Quarkus REST Resource
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.quarkus;

import javax.ws.rs.DefaultValue;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import java.lang.System.Logger;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.List;

import static java.lang.System.Logger.Level.INFO;
import static java.lang.invoke.MethodHandles.lookup;

@Path("/quarkus")
@Produces(MediaType.TEXT_PLAIN)
public class QuarkusResource {

    private static final Logger LOGGER = System.getLogger(lookup().lookupClass().getName());

    private final StatisticsRepository repository;

    public QuarkusResource(StatisticsRepository statisticsRepository) {
        this.repository = statisticsRepository;
    }

    //  ====> insert the remaining code blocks under his line <====


}
----

[WARNING]
====
You should see the IDE complaining about the `StatisticsRepository` class. 
Don't worry about it now as we will be adding this class in the next few steps.
====

[TIP]
====
After copying and pasting inside your class you may get your class with wrong indentation. 
You can ask the IDE to `Format Document` by choosing one of the following two options:

* Context Menu (mouse right-click) inside the class file and selecting `Format Document` option
* Opening the Command Palette (`Ctrl + Shift + P` or `Cmd + Shift + P` on mac), start typing `Format...` and select `Format Document`
====

Let's add a `hello` method returning *_Hello World_*, so we can quickly check if our endpoint responds or not.

[[quarkus-listing-rest-resource-2]]
.Hello Method
[source,java,indent=0,role=copy]
----
    @GET
    public String hello() {
        LOGGER.log(INFO, "Quarkus: hello");
        return "Quarkus: hello";
    }
----

[WARNING]
====
After copying and pasting a piece of code inside your class you may accidentally put it outside the `{ }` curling braces. 

Watch out for the IDE highlighting any syntax mistake/error and fix it!
====


Let's now add a `cpu` method that consumes CPU depending on a few optional parameters.

* `iterations`: the more iterations you have, the more CPU it consumes.
* `db`: if this parameter is set to true, the statistics are stored in the database.
That allows us to check the impact of the database on the CPU consumption.
* `desc`: any optional description you want to persist in the database

[[quarkus-listing-rest-resource-3]]
.CPU Method
[source,java,indent=0,role=copy]
----
    @GET
    @Path("/cpu")
    public String cpu(@QueryParam("iterations") @DefaultValue("10") Long iterations,
                      @QueryParam("db") @DefaultValue("false") Boolean db,
                      @QueryParam("desc") String desc) {
        LOGGER.log(INFO, "Quarkus: cpu: {0} {1} with desc {2}", iterations, db, desc);
        Long iterationsDone = iterations;

        Instant start = Instant.now();
        if (iterations == null) {
            iterations = 20000L;
        } else {
            iterations *= 20000;
        }

        while (iterations > 0) {
            if (iterations % 20000 == 0) {
                try {
                    Thread.sleep(20);
                } catch (InterruptedException ie) {
                }
            }
            iterations--;
        }

        if (db) {
            Statistics statistics = new Statistics();
            statistics.type = Type.CPU;
            statistics.parameter = iterationsDone.toString();
            statistics.duration = Duration.between(start, Instant.now());
            statistics.description = desc;
            repository.persist(statistics);
        }

        String msg = "Quarkus: CPU consumption is done with " + iterationsDone + " iterations in " + Duration.between(start, Instant.now()).getNano() + " nano-seconds.";
        if (db) {
            msg += " The result is persisted in the database.";
        }
        return msg;
    }
----

[WARNING]
====
You should see the IDE complaining about the `Statistics` class. 
Don't worry about it now as we will be adding this class in the next few steps.
====

Now add a `memory` method that consumes memory depending on a few optional parameters.

* `bites`: the more bits you have, the more memory it consumes.
* `db`: if this parameter is set to true, the statistics are stored in the database.
* `desc`: any optional description you want to persist in the database

[[quarkus-listing-rest-resource-4]]
.Memory Method
[source,java,indent=0,role=copy]
----
    @GET
    @Path("/memory")
    public String memory(@QueryParam("bites") @DefaultValue("10") Integer bites,
                         @QueryParam("db") @DefaultValue("false") Boolean db,
                         @QueryParam("desc") String desc) {
        LOGGER.log(INFO, "Quarkus: memory: {0} {1} with desc {2}", bites, db, desc);

        Instant start = Instant.now();
        if (bites == null) {
            bites = 1;
        }

        HashMap hunger = new HashMap<>();
        for (int i = 0; i < bites * 1024 * 1024; i += 8192) {
            byte[] bytes = new byte[8192];
            hunger.put(i, bytes);
            for (int j = 0; j < 8192; j++) {
                bytes[j] = '0';
            }
        }

        if (db) {
            Statistics statistics = new Statistics();
            statistics.type = Type.MEMORY;
            statistics.parameter = bites.toString();
            statistics.duration = Duration.between(start, Instant.now());
            statistics.description = desc;
            repository.persist(statistics);
        }

        String msg = "Quarkus: Memory consumption is done with " + bites + " bites in " + Duration.between(start, Instant.now()).getNano() + " nano-seconds.";
        if (db) {
            msg += " The result is persisted in the database.";
        }
        return msg;
    }
----

Let's also create a method to retrieve the statistics from the database.
This is very easy to do with https://quarkus.io/guides/hibernate-orm-panache[Panache].

[[quarkus-listing-rest-resource-5]]
.Method Returning all the Statistics
[source,java,indent=0,role=copy]
----
    @GET
    @Path("/stats")
    @Produces(MediaType.APPLICATION_JSON)
    public List<Statistics> stats() {
        LOGGER.log(INFO, "Quarkus: retrieving statistics");
        return Statistics.findAll().list();
    }
----

At this stage the code does not compile yet because there are a few missing classes.
Let's create them now.

== Transactions and ORM

When the database is enabled, the statistics are stored in the database.
For that we need a `Statistics` entity with a few enumerations that will be mapped to the PostgreSQL database.
Create the `Statistics.java` entity in the `src/main/java/io/containerapps/javaruntime/workshop/quarkus` folder.

[[quarkus-listing-entity]]
.Statistics Entity
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.quarkus;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Table;
import java.time.Duration;
import java.time.Instant;

@Entity
@Table(name = "Statistics_Quarkus")
public class Statistics extends PanacheEntity {

    @Column(name = "done_at")
    public Instant doneAt = Instant.now();
    public Framework framework = Framework.QUARKUS;
    public Type type;
    public String parameter;
    public Duration duration;
    public String description;
}

enum Type {
    CPU, MEMORY
}

enum Framework {
    QUARKUS, MICRONAUT, SPRINGBOOT
}
----

For manipulating the entity, we need a repository.
Create the `StatisticsRepository.java` class under the same package.
Notice that `StatisticsRepository` is a https://quarkus.io/guides/hibernate-orm-panache[Panache Repository] that extends the `PanacheRepository` class.

[[quarkus-listing-repository]]
.Statistics Repository
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.quarkus;

import io.quarkus.hibernate.orm.panache.PanacheRepository;

import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;

@ApplicationScoped
@Transactional
public class StatisticsRepository implements PanacheRepository<Statistics> {

}
----

== Compiling the Quarkus Application

You should have all the code to compile the application.
To make sure you have all the code and dependencies, run the following command in the `quarkus-app` folder:

[source,shell,role=copy]
----
cd $PROJECT_SOURCE/quarkus-app
mvn compile
----

[TIP]
====
Besides using Maven commands directly in the IDE Terminal you can use the pre-defined commands available as Tasks in your Workspace.
To access these commands just open the Task Manager view at left menu of your IDE (see screenshot below) and choose the task named `01: Quarkus - JVM Package` which triggers a `mvn package -DskipTests` in a terminal.

.*Click to see how use the Task Manager inside your DevWorkspace*
[%collapsible]
=====
image::../imgs/module-3/VSCode_task_manager_mvn_package.gif[Task Manager - JVM Package]
=====

All these Tasks are defined as `commands` in the project's *Devfile* (`$PROJECT_SOURCE/devfile.yaml`) following the link:https://devfile.io[Devfile.io] standard.
====

[NOTE]
====
At this point, you may be asking yourself about the Maven dependencies since we haven't touched the project's `pom.xml`. That's true. To make things a bit easier during the Lab, we have already set all the project dependencies for you. 
You can check the `quarkus-app/pom.xml` file by opening it in the editor if you want to.
====

== Configuring the Quarkus Application

Because we will run our application in different environments (dev, test and prod), we need to configure our runtime for such.

To make sure our 3 microservices can run side by side, we need to configure the listening port of the Quarkus application.
To have this service exposed on the port 8701, add the following configuration in the `src/main/resources/application.properties` file.

[[quarkus-listing-config]]
.Configuration Properties
[source,properties,indent=0, role=copy]
----
%dev.quarkus.http.port=8701
----

In addition to that, during development and testing (inner-loop) we will be using a InMemory Database (H2 Db). To configure Quarkus to use H2 InMem DB in dev and test modes, add the following properties.

.Configuration Properties
[source,properties,indent=0, role=copy]
----
# Dev Config
%dev.quarkus.http.port=8701

# Use InMem H2 DB for dev and test profiles
quarkus.datasource.db-kind=h2
%dev.quarkus.datasource.jdbc.url=jdbc:h2:mem:test
%dev.quarkus.hibernate-orm.database.generation=drop-and-create
%dev.quarkus.hibernate-orm.log.sql=true

# Testing config
%test.quarkus.datasource.db-kind=h2
----

== Testing the Quarkus Application Locally

Now, to make sure that the application works as expected, we need to write some tests.
For that we will use https://quarkus.io/guides/getting-started-testing[Quarkus Test Framework] that is based on https://junit.org/junit5/[JUnit 5] and use https://github.com/rest-assured/rest-assured[RESTAssured].

A very common need is to start the services which your Quarkus application depends on before starting test scenarios. For instance, in our application, we need a Database instance (link:https://www.h2database.com/[H2] in our case) in order to execute our test scenarios. To address this need, Quarkus provides the `@io.quarkus.test.common.QuarkusTestResource` annotation, which allows you to use an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`. 
Thankfully, Quarkus provides an implementation for H2 Database out of the box (`io.quarkus.test.h2.H2DatabaseTestResource`) which starts an H2 database for your Tests.

[NOTE]
====
For more details on this feature, see link:https://quarkus.io/guides/getting-started-testing#quarkus-test-resource[Starting services before the Quarkus application starts] in the link:https://quarkus.io/guides/getting-started-testing[Quakus Testing Guide].

Quarkus also integrates with https://www.testcontainers.org[Testcontainers], which can automatically start a Database using Docker (if present in your local dev environment) with its https://quarkus.io/guides/dev-services[DevServices] feature. But this is outside the scope of this workshop.
====

Create the `QuarkusResourceTest.java` class under the `src/test/java/io/containerapps/javaruntime/workshop/quarkus` folder.
Then add the following to the header of the class.

[[quarkus-listing-test-1]]
.Header of the Test Class
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.quarkus;

import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.h2.H2DatabaseTestResource;
import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.*;

@QuarkusTest
@QuarkusTestResource(H2DatabaseTestResource.class)
public class QuarkusResourceTest {


}
----

[IMPORTANT]
====
Maven based projects follows a link:https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html[standard directory layout].

Application _Test classes_ *must* reside under the `src/test/java` directory
[source, subs=+quotes]
-----
.
├── pom.xml
├── src
│   └── #test#
│       └── java
│           └── ...
-----

So, pay attention to where you are creating your class files inside your project!
====

First, let's write a test to check if the `hello` method returns the right _Hello World_ string.

[[quarkus-listing-test-2]]
.Testing the Hello Endpoint
[source,java,indent=0,role=copy]
----
  @Test
  public void testHelloEndpoint() {
      given()
        .when().get("/quarkus")
        .then()
          .statusCode(200)
          .body(is("Quarkus: hello"));
  }
----

Then, we write another test to check that the `cpu` method consumes CPU and takes the right parameters.

[[quarkus-listing-test-3]]
.Testing the CPU Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testCpuWithDBAndDescEndpoint() {
        given().param("iterations", 1).param("db", true).param("desc", "Java17")
          .when().get("/quarkus/cpu")
          .then()
            .statusCode(200)
            .body(startsWith("Quarkus: CPU consumption is done with"))
            .body(not(containsString("Java17")))
            .body(endsWith("The result is persisted in the database."));
    }
----

And we do the same for the `memory` method.

[[quarkus-listing-test-4]]
.Testing the Memory Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testMemoryWithDBAndDescEndpoint() {
        given().param("bites", 1).param("db", true).param("desc", "Java17")
          .when().get("/quarkus/memory")
          .then()
            .statusCode(200)
            .body(startsWith("Quarkus: Memory consumption is done with"))
            .body(not(containsString("Java17")))
            .body(endsWith("The result is persisted in the database."));
    }
----

Let's also create a simple test to make sure the statistics are stored in the database.

[[quarkus-listing-test-5]]
.Testing Retrieving the Statistics from the Database
[source,java,indent=0,role=copy]
----
    @Test
    public void testStats() {
        given()
          .when().get("/quarkus/stats")
          .then()
            .statusCode(200);
    }
----

Now that you have your tests methods, run them with the following command:

[source,shell,role=copy]
----
cd $PROJECT_SOURCE/quarkus-app
mvn test
----

[NOTE]
====
A pop-up saying "*A new process is now listening on port 9092...*" may appear at the bottom left during the test run. Just click `No` or close it! 
====

All the tests should pass and you should see the following output:

[source,shell]
----
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

[TIP]
====
You can also use the Task Manager to trigger Maven Test by executing the task `02: Quarkus - Test` which triggers a `mvn test` in a separate Terminal.
====

== Running the Quarkus Application Locally

Now that the tests are all green, let's execute the application locally and execute a few `curl` commands to test the exposed endpoints. 

Execute the following command inside the `quarkus-app` directory:

[source,shell,role=copy]
----
mvn quarkus:dev
----

[TIP]
====
You can also use the Task Manager to start Quarkus in Dev Mode by executing the task `03: Quarkus - Start in dev mode (Hot reload + debug)` which triggers a `mvn quarkus:dev` in a separate Terminal.

.*Click to see how use the Task Manager inside your DevWorkspace*
[%collapsible]
=====
image::../imgs/module-3/VSCode_task_manager_mvn_quarkus-dev.gif[Task Manager - Quarkus dev mode]
=====

====

[NOTE]
====
When you start a Quarkus app in dev mode inside your Workspace watch out for two pop-ups that appear at the bottom left of your IDE.

 * the first one says "*A new process is listening on port 5005...*" which is the JVM Debug port. Just ignore and close this one.
 * the second one says "*Process quarkus-app is now listening on port 8701*" which is the http port we configured our app to listen to. *click Open in a new tab button* and then *click Open* in the next pop-up (VSCode needs your consent every time you attempt to open an external URL).

This pop-up will appear every time you start a process which listens to a TCP/HTTP port. This is how *DevSpaces* exposes your app for external access during development phase.
====

In another terminal you can execute the following `curl` commands to invoke the endpoint:

[source,shell,role=copy]
----
curl -w '\n' 'localhost:8701/quarkus'
curl -w '\n' 'localhost:8701/quarkus/cpu?iterations=10&db=true&desc=java17'
curl -w '\n' 'localhost:8701/quarkus/memory?bites=10&db=true&desc=java17'
----

[TIP]
====
To open a new Terminal in your Workspace just click the `+` icon located at the top bar of the Terminal panel. If your Teminal is not open just hit `Ctrl + \`` (`command + \`` for Mac).

You can also open a new Terminal by using the VSCode Command prompt by `Ctrl + Shift + P` (`command + Shift + P` on Mac) and typing `new terminal` and choosing the last option named `New Terminal to DevWorkspace Container`.
====

You can change the parameters to see how the application behaves.
Change the number of iterations and the number of bites to see how the performance is impacted (with and without database).

[source,shell,role=copy]
----
curl -w '\n' 'localhost:8701/quarkus/cpu?iterations=50'
curl -w '\n' 'localhost:8701/quarkus/cpu?iterations=100'
curl -w '\n' 'localhost:8701/quarkus/cpu?iterations=100&db=true&desc=smoke%20test'

curl -w '\n' 'localhost:8701/quarkus/memory?bites=50'
curl -w '\n' 'localhost:8701/quarkus/memory?bites=100'
curl -w '\n'  'localhost:8701/quarkus/memory?bites=100&db=true&desc=smoke%20test'
----

You can check the content of the database with:

[source,shell,role=copy]
----
curl -s 'localhost:8701/quarkus/stats' | jq
----

You should see an output like the following.

[source, json]
----
[
  {
    "id": 1,
    "doneAt": "2023-05-16T14:16:37.744772Z",
    "framework": "QUARKUS",
    "type": "CPU",
    "parameter": "0",
    "duration": 0.211009419,
    "description": "java17"
  },
  {
    "id": 2,
    "doneAt": "2023-05-16T14:16:49.520952Z",
    "framework": "QUARKUS",
    "type": "MEMORY",
    "parameter": "10",
    "duration": 0.023290367,
    "description": "java17"
  },
  {
    "id": 3,
    "doneAt": "2023-05-16T14:18:11.559207Z",
    "framework": "QUARKUS",
    "type": "CPU",
    "parameter": "0",
    "duration": 2.039769092,
    "description": "smoke test"
  },
  {
    "id": 4,
    "doneAt": "2023-05-16T14:18:28.166053Z",
    "framework": "QUARKUS",
    "type": "MEMORY",
    "parameter": "100",
    "duration": 0.188299506,
    "description": "smoke test"
  }
]
----

[NOTE]
====
when you are done testing your Quarkus app just go to the Terminal running the quarkus-app JVM process and hit `Ctrl + c` to terminal the JVM process.
====

== Setting up for Staging

To wrap up with our quarkus app we need to make two changes in its configuration:

1. set the http connector to listen to port 8080
2. connect to Postgres Database instead of H2.
+
We have already deployed one Postgres instance in the `{user}-staging` project namespace using the link:https://access.crunchydata.com/documentation/postgres-operator/v5/[Crunchy Data PGO Operator], so you don't need to worry about setting up Postgres yourself.
+

To make these changes open the `$PROJECT_SOURCE/quarkus-app/src/main/resources/application.properties` config file and *add* the following properties at the bottom of the file.

.Prod Configuration Properties
[source,properties,indent=0, role=copy]
----

# Prod Config
%prod.quarkus.http.port=8080

# Postgres DB connection
%prod.quarkus.datasource.db-kind=postgresql
%prod.quarkus.datasource.username=postgres
%prod.quarkus.datasource.password=password
%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://postgres-ha/postgres
%prod.quarkus.hibernate-orm.database.generation=none
----

Let's execute one more command to make sure our app can be packaged by Maven before we commit this last change.

[source,shell]
----
cd $PROJECT_SOURCE/quarkus-app
mvn package
----

Wait for your maven build success.

[source,shell]
----
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  14.707 s
[INFO] Finished at: 2023-05-16T14:30:43Z
[INFO] ------------------------------------------------------------------------
----

And we you're ready to commit and push it!

== Push our changes to Github

Alright, now lets push this change to our git repo. From the DevWorkspace Terminal execute:

[source,shell]
----
cd $PROJECT_SOURCE/
git add .
git commit -m "adding PostgresDB connection properties"
git push
----

[TIP]
====
You can also use the VSCode integrated Source Control extension to commit and push your changes.

.*Click to see to use it*
[%collapsible]
======
image::../imgs/module-3/VSCode_git_commit_push.gif[VSCode integrated Source Control - git sync]
======
====

That's it for the Quarkus application.
Now, let's move to the Micronaut application.
