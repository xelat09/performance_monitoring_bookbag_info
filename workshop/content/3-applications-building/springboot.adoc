:guid: %guid%
:user: %user%
:sectlinks:
:sectanchors:
:markup-in-source: verbatim,attributes,quotes
:source-highlighter: highlight.js

[[springboot]]
= Developing the Spring Boot Application

[IMPORTANT]
====
Due to our Lab session time constraint, we already provided the code for the app, so you have time to experience other exiting capabilities available in the platform.

This version of the app implements the same logic, exposing the exact same resources, but now using *SpringBoot* as its underline Runtime.

Feel free to go through the source code. But #*you don't need to code any Java Class in this section*#. 

*You can jump right to the* link:#Running-the-Springboot-Application-Locally[*Running the Springboot Application Locally*] section and just run the Maven commands (or run the Tasks using the IDE Task Manager) to run and test the app inside your DevWorkspace.
====


In this section you will:

* Develop a REST API with Spring Boot that consumes memory and CPU (the exact same algorithm than before)
* Add a Statistics persistent entity to store metrics in a PostgreSQL database
* Configure the application
* Develop some tests to validate the behavior of the application
* Test and run the application locally
* Check a few metrics locally

You should have a directory called `springboot-app` inside your project repo (`$PROJECT_SOURCE/`). This is the root of the Springboot microservice source code that we will be working on during this this section.

== The Spring Boot REST Resource

The Spring Boot application is a simple REST resource that exposes a single endpoint to consume memory and CPU.
Before creating the REST resource, let's check the existing main Spring Boot class that will bootstrap the application.
Check the following code in the `SpringbootApplication` class, under the `io/containerapps/javaruntime/workshop/springboot` package.

[[springboot-listing-rest-resource]]
.Bootstrapping Spring Boot Class
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.springboot;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootApplication.class, args);
	}

}


----

The REST resource is defined in the `SpringbootResource` class.
Create a new file called `SpringbootResource.java`, under the `io.containerapps.javaruntime.workshop.springboot` directory.
Then add the following to the header of this class file (replace any existing content generated by the IDE).

As you can see in the header of the class, the resource is exposed on the `/springboot` path.

[[springboot-listing-rest-resource-1]]
.Header of the Spring Boot REST Resource
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.springboot;

import static java.lang.System.Logger.Level.INFO;
import static java.lang.invoke.MethodHandles.lookup;

import java.lang.System.Logger;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/springboot")
public class SpringbootResource {

    private static final Logger LOGGER = System.getLogger(lookup().lookupClass().getName());

    private final StatisticsRepository repository;

    public SpringbootResource(StatisticsRepository statisticsRepository) {
        this.repository = statisticsRepository;
    }


}
----

Let's add a `hello` method returning _Hello World_, so we can quickly check if our endpoint responds or not.

[[springboot-listing-rest-resource-2]]
.Hello Method
[source,java,indent=0,role=copy]
----
    @GetMapping(produces = MediaType.TEXT_PLAIN_VALUE)
    public String hello() {
        LOGGER.log(INFO, "Spring Boot: hello");
        return "Spring Boot: hello";
    }
----

Let's now add a `cpu` method that consumes CPU depending on a few optional parameters.

* `iterations`: the more iterations you have, the more CPU it consumes.
* `db`: if this parameter is set to true, the statistics are stored in the database.
That allows us to check the impact of the database on the CPU consumption.
* `desc`: any optional description you want to persist in the database

[[springboot-listing-rest-resource-3]]
.CPU Method
[source,java,indent=0,role=copy]
----
    @GetMapping(path = "/cpu", produces = MediaType.TEXT_PLAIN_VALUE)
    public String cpu(@RequestParam(value = "iterations", defaultValue = "10") Long iterations,
                      @RequestParam(value = "db", defaultValue = "false") Boolean db,
                      @RequestParam(value = "desc", required = false) String desc) {
        LOGGER.log(INFO, "Spring Boot: cpu: {0} {1} with desc {2}", iterations, db, desc);
        Long iterationsDone = iterations;
    
        Instant start = Instant.now();
        if (iterations == null) {
            iterations = 20000L;
        } else {
            iterations *= 20000;
        }
        while (iterations > 0) {
            if (iterations % 20000 == 0) {
                try {
                    Thread.sleep(20);
                } catch (InterruptedException ie) {
                }
            }
            iterations--;
        }
    
        if (db) {
            Statistics statistics = new Statistics();
            statistics.type = Type.CPU;
            statistics.parameter = iterations.toString();
            statistics.duration = Duration.between(start, Instant.now());
            statistics.description = desc;
            repository.save(statistics);
        }
    
        String msg = "Spring Boot: CPU consumption is done with " + iterationsDone + " iterations in " + Duration.between(start, Instant.now()).getNano() + " nano-seconds.";
        if (db) {
            msg += " The result is persisted in the database.";
        }
        return msg;
    }
----

Now, add a `memory` method that consumes memory depending on a few optional parameters.

* `bites`: the more bits you have, the more memory it consumes.
* `db`: if this parameter is set to true, the statistics are stored in the database.
* `desc`: any optional description you want to persist in the database

[[springboot-listing-rest-resource-4]]
.Memory Method
[source,java,indent=0,role=copy]
----
    @GetMapping(path = "/memory", produces = MediaType.TEXT_PLAIN_VALUE)
    public String memory(@RequestParam(value = "bites", defaultValue = "10") Integer bites,
                         @RequestParam(value = "db", defaultValue = "false") Boolean db,
                         @RequestParam(value = "desc", required = false) String desc) {
        LOGGER.log(INFO, "Spring Boot: memory: {0} {1} with desc {2}", bites, db, desc);
    
        Instant start = Instant.now();
        if (bites == null) {
            bites = 1;
        }
        HashMap hunger = new HashMap<>();
        for (int i = 0; i < bites * 1024 * 1024; i += 8192) {
            byte[] bytes = new byte[8192];
            hunger.put(i, bytes);
            for (int j = 0; j < 8192; j++) {
                bytes[j] = '0';
            }
        }
    
        if (db) {
            Statistics statistics = new Statistics();
            statistics.type = Type.MEMORY;
            statistics.parameter = bites.toString();
            statistics.duration = Duration.between(start, Instant.now());
            statistics.description = desc;
            repository.save(statistics);
        }
    
        String msg = "Spring Boot: Memory consumption is done with " + bites + " bites in " + Duration.between(start, Instant.now()).getNano() + " nano-seconds.";
        if (db) {
            msg += " The result is persisted in the database.";
        }
        return msg;
    }
----

Let's also create a method to retrieve the statistics from the database.

[[springboot-listing-rest-resource-5]]
.Method Returning all the Statistics
[source,java,indent=0,role=copy]
----
    @GetMapping(path = "/stats", produces = MediaType.APPLICATION_JSON_VALUE)
    public List<Statistics> stats() {
        LOGGER.log(INFO, "Spring Boot: retrieving statistics");
        List<Statistics> result = new ArrayList<Statistics>();
        for (Statistics stats : repository.findAll()) {
            result.add(stats);
        }
        return result;
    }
----

At this stage the code does not compile yet, because there are a few missing classes.
Let's create them now.

== Transactions and ORM

When the database is enabled, the statistics are stored in the database.
For that we need a `Statistics` entity with a few enumerations.
Create the `Statistics.java` entity in the `src/main/java/io/containerapps/javaruntime/workshop/springboot` directory.

[[springboot-listing-entity]]
.Statistics Entity
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.springboot;

import java.time.Duration;
import java.time.Instant;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name = "Statistics_Springboot")
public class Statistics {

    @GeneratedValue
    @Id
    private Long id;
    @Column(name = "done_at")
    public Instant doneAt = Instant.now();
    public Framework framework = Framework.SPRINGBOOT;
    public Type type;
    public String parameter;
    public Duration duration;
    public String description;
}

enum Type {
    CPU, MEMORY
}

enum Framework {
    QUARKUS, MICRONAUT, SPRINGBOOT
}
----

For manipulating the entity, we need a repository.
Create the `StatisticsRepository.java` class under the same package.

[[springboot-listing-repository]]
.Statistics Repository
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.springboot;

import org.springframework.data.repository.CrudRepository;

interface StatisticsRepository extends CrudRepository<Statistics, Long> {
  
}
----

== Compiling the Spring Boot Application

You should have all the code to compile the application.
To make sure you have all the code and dependencies, run the following command in the `springboot-app` folder:

[source,shell,role=copy]
----
cd $PROJECT_SOURCE/springboot-app
mvn compile
----

[TIP]
====
Besides using Maven commands directly in the IDE Terminal you can use the pre-defined commands available as Tasks in your Workspace.
To access these commands just open the Task Manager view at left menu of your IDE (see screenshot below) and choose the task named `07: SpringBoot - JVM Package` which triggers a `mvn package -DskipTests` in a Terminal.

.*Click to see how use the Task Manager inside your DevWorkspace*
[%collapsible]
=====
image::../imgs/module-3/VSCode_task_manager_mvn_package.gif[Task Manager - JVM Package]
=====

All these Tasks are defined as `commands` in the project's *Devfile* (`$PROJECT_SOURCE/devfile.yaml`) following the link:https://devfile.io[Devfile.io] standard.
====

[NOTE]
====
At this point, you may be asking yourself about the Maven dependencies since we haven't touched the project's `pom.xml`. That's true. To make things a bit easier during the Lab, we have already set all the project dependencies for you.
You can check the `springboot-app/pom.xml` file by opening it in the editor if you want to.
====

== Configuring the Spring Boot Application

During our development and testing phase we will be using an InMemory Database (link:https://www.h2database.com/[H2] in our case). Later when we will be deploying our app to our Openshift Cluster we will switch to a Postgres SQL Database instance.
In Dev we also need this service to be exposed on the port 8703.

Add the following to the `src/main/resources/application.properties` file.

[[springboot-listing-config]]
.Configuration Properties
[source,properties,indent=0,role=copy]
----
server.port=8703
# Enable metrics endpoints
management.endpoints.web.exposure.include=health,info

#---
spring.config.activate.on-profile=development
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

## Hibernate Properties
spring.jpa.show-sql=true

# Hibernate ddl auto (create, create-drop, validate, update)
spring.jpa.hibernate.ddl-auto=create-drop
----

== Testing the Spring Boot Application Locally

Now, to make sure that the application works as expected, we need to write some tests.

Open up the `SpringbootApplicationTests` class under the `src/test/java/io/containerapps/javaruntime/workshop/springboot` folder, and add:

[[springboot-listing-test]]
.Test Class Configuring Testcontainers
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.springboot;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
class SpringbootApplicationTests {

        @Test
        void contextLoads() {
        }

}
----

Then all our tests go into the `SpringbootResourceTest` class.
Create the `SpringbootResourceTest.java` class under the same package that `SpringbootApplicationTests`.

[[springboot-listing-test-1]]
.Header of the Test Class
[source,java,indent=0,role=copy]
----
package io.containerapps.javaruntime.workshop.springboot;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT)
class SpringbootResourceTest {

    private static String basePath = "http://localhost:8703/springboot";

    @Autowired
    private TestRestTemplate restTemplate;
}
----

First, let's write a test to check that the `hello` method returns the right _Hello World_ string.

[[springboot-listing-test-2]]
.Testing the Hello Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testHelloEndpoint() {
        ResponseEntity<String> response = this.restTemplate.
            getForEntity(basePath, String.class);
    
        assertEquals(response.getStatusCode(), HttpStatus.OK);
        assertThat(response.getBody()).contains("Spring Boot: hello");
    }
----

Then, we write another test to check that the `cpu` method consumes CPU and takes the right parameters.

[[springboot-listing-test-3]]
.Testing the CPU Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testCpuWithDBAndDescEndpoint() {
        ResponseEntity<String> response = this.restTemplate.
            getForEntity(basePath + "/cpu?iterations=1&db=true&dec=Java17", String.class);
    
        assertEquals(response.getStatusCode(), HttpStatus.OK);
        assertThat(response.getBody())
            .startsWith("Spring Boot: CPU consumption is done with")
            .doesNotContain("Java17")
            .endsWith("The result is persisted in the database.");
    }
----

And we do the same for the `memory` method.

[[springboot-listing-test-4]]
.Testing the Memory Endpoint
[source,java,indent=0,role=copy]
----
    @Test
    public void testMemoryWithDBAndDescEndpoint() {
        ResponseEntity<String> response = this.restTemplate.
            getForEntity(basePath + "/memory?bites=1&db=true&desc=Java17", String.class);
    
        assertEquals(response.getStatusCode(), HttpStatus.OK);
        assertThat(response.getBody())
            .startsWith("Spring Boot: Memory consumption is done with")
            .doesNotContain("Java17")
            .endsWith("The result is persisted in the database.");
    }
----

Let's also create a simple test to make sure the statistics are stored in the database.

[[springboot-listing-test-5]]
.Testing Retrieving the Statistics from the Database
[source,java,indent=0,role=copy]
----
    @Test
    public void testStats() {
        ResponseEntity<String> response = this.restTemplate.
            getForEntity(basePath + "/stats", String.class);
    
        assertEquals(response.getStatusCode(), HttpStatus.OK);
    }
----

Now that you have your tests methods, run them with the following command:

[source,shell,role=copy]
----
cd $PROJECT_SOURCE/springboot-app
mvn test
----

[NOTE]
====
A pop-up saying "*A new process is now listening on port 8783...*" may appear at the bottom left during the test run. Just click `No` or close it! 
====

All the tests should pass and you should see the following output:

[source,shell]
----
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

[TIP]
====
You can also use the Task Manager to trigger Maven Test by executing the task `09: SpringBoot - Test` which triggers a `mvn test` in a separate Terminal.
====

[#Running-the-Springboot-Application-Locally]
== Running the SpringBoot Application Locally

Now that the tests are all green, let's execute the application locally and execute a few `curl` commands to test the exposed endpoints.

Execute the following command inside the `springboot-app` directory:

[source,shell,role=copy]
----
cd $PROJECT_SOURCE/springboot-app
mvn spring-boot:run
----

[TIP]
====
You can also use the Task Manager to start Springboot in Dev Mode by executing the task `08: Springboot - Start in dev mode` which triggers a `mvn spring-boot-run` in a separate Terminal.
====

[NOTE]
====
When you start a Springboot app in dev mode inside your Workspace watch out for a pop-up that appear at the bottom left of your IDE.

 * the pop-up one says "Process springboot-app is now listening on port 8703" which is the http port we configured our app to listen to. *click Open in a new tab button* and then *click Open* in the next pop-up (VSCode needs your consent every time you attempt to open an external URL).

This pop-up will appear every time you start a process which listens to a TCP/HTTP port. This is how *DevSpaces* exposes your app for external access during development phase.
====

In another terminal you can execute the following `curl` commands to invoke the endpoint:

[source,shell,role=copy]
----
curl -w '\n' 'localhost:8703/springboot'
curl -w '\n' 'localhost:8703/springboot/cpu?iterations=10&db=true&desc=java17'
curl -w '\n' 'localhost:8703/springboot/memory?bites=10&db=true&desc=java17'
----

You can change the parameters to see how the application behaves.
Change the number of iterations and the number of bites to see how the performance is impacted (with and without database).

[source,shell,role=copy]
----
curl -w '\n' 'localhost:8703/springboot/cpu?iterations=50'
curl -w '\n' 'localhost:8703/springboot/cpu?iterations=100'
curl -w '\n' 'localhost:8703/springboot/cpu?iterations=100&db=true&desc=smoke%20test'

curl -w '\n' 'localhost:8703/springboot/memory?bites=50'
curl -w '\n' 'localhost:8703/springboot/memory?bites=100'
curl -w '\n' 'localhost:8703/springboot/memory?bites=100&db=true&desc=smoke%20test'
----

You can check the content of the database with:

[source,shell,role=copy]
----
curl -s 'localhost:8703/springboot/stats' | jq
----

You should see an output like the following.

[source, json]
----
[
  {
    "id": 1,
    "doneAt": "2023-05-16T14:16:37.744772Z",
    "framework": "SPRINGBOOT",
    "type": "CPU",
    "parameter": "0",
    "duration": 0.211009419,
    "description": "java17"
  },
  {
    "id": 2,
    "doneAt": "2023-05-16T14:16:49.520952Z",
    "framework": "SPRINGBOOT",
    "type": "MEMORY",
    "parameter": "10",
    "duration": 0.023290367,
    "description": "java17"
  },
  {
    "id": 3,
    "doneAt": "2023-05-16T14:18:11.559207Z",
    "framework": "SPRINGBOOT",
    "type": "CPU",
    "parameter": "0",
    "duration": 2.039769092,
    "description": "smoke test"
  },
  {
    "id": 4,
    "doneAt": "2023-05-16T14:18:28.166053Z",
    "framework": "SPRINGBOOT",
    "type": "MEMORY",
    "parameter": "100",
    "duration": 0.188299506,
    "description": "smoke test"
  }
]
----

That's it.
We now have developed and tested locally our three microservices.
Time to containerize them and deploy them to our Red Hat Openshift Cluster.
